# ìƒíƒœ ê´€ë¦¬ ë° ì•„í‚¤í…ì²˜ ê·œì¹™

## ğŸ—ï¸ ì•„í‚¤í…ì²˜ íŒ¨í„´

- **Clean Architecture**: ë°ì´í„°, ë„ë©”ì¸, í”„ë ˆì  í…Œì´ì…˜ ë ˆì´ì–´ ë¶„ë¦¬
- **Repository Pattern**: ë°ì´í„° ì ‘ê·¼ ì¶”ìƒí™”
- **Use Case Pattern**: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ìº¡ìŠí™”

## ğŸ”„ ìƒíƒœ ê´€ë¦¬ ì „ëµ

- **Riverpod**: ì „ì—­ ìƒíƒœ ë° ì˜ì¡´ì„± ì£¼ì…
- **BLoC**: ë³µì¡í•œ ìƒíƒœ ë¡œì§ ë° ì´ë²¤íŠ¸ ì²˜ë¦¬
- **Local State**: UI ì „ìš© ìƒíƒœëŠ” StatefulWidget ë‚´ë¶€ì—ì„œë§Œ ê´€ë¦¬

## ğŸ“Š ìƒíƒœ ë¶ˆë³€ì„±

- **Freezed**: ëª¨ë“  ìƒíƒœ í´ë˜ìŠ¤ì— Freezed ì ìš©
- **Copy With**: ìƒíƒœ ì—…ë°ì´íŠ¸ëŠ” copyWith ë©”ì„œë“œ ì‚¬ìš©
- **Equatable**: ìƒíƒœ ë¹„êµë¥¼ ìœ„í•œ Equatable êµ¬í˜„

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ

- **Provider í…ŒìŠ¤íŠ¸**: Riverpod provider ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
- **BLoC í…ŒìŠ¤íŠ¸**: BLoC ì´ë²¤íŠ¸ ë° ìƒíƒœ í…ŒìŠ¤íŠ¸
- **Repository í…ŒìŠ¤íŠ¸**: ë°ì´í„° ë ˆì´ì–´ ëª¨í‚¹ í…ŒìŠ¤íŠ¸
- **Widget í…ŒìŠ¤íŠ¸**: UI ì»´í¬ë„ŒíŠ¸ í…ŒìŠ¤íŠ¸

## ğŸ“‹ ì½”ë“œ ì˜ˆì‹œ

### Riverpod Provider

```dart
@riverpod
class UserNotifier extends _$UserNotifier {
  @override
  FutureOr<User?> build() => null;

  Future<void> fetchUser(String id) async {
    state = const AsyncValue.loading();
    try {
      final user = await _userRepository.getUser(id);
      state = AsyncValue.data(user);
    } catch (e, stack) {
      state = AsyncValue.error(e, stack);
    }
  }
}
```

### BLoC Pattern

```dart
@freezed
class UserEvent with _$UserEvent {
  const factory UserEvent.fetchUser(String id) = _FetchUser;
}

@freezed
class UserState with _$UserState {
  const factory UserState.initial() = _Initial;
  const factory UserState.loading() = _Loading;
  const factory UserState.loaded(User user) = _Loaded;
  const factory UserState.error(String message) = _Error;
}

class UserBloc extends Bloc<UserEvent, UserState> {
  UserBloc(this._repository) : super(const UserState.initial()) {
    on<_FetchUser>(_onFetchUser);
  }

  Future<void> _onFetchUser(_FetchUser event, Emitter<UserState> emit) async {
    emit(const UserState.loading());
    try {
      final user = await _repository.getUser(event.id);
      emit(UserState.loaded(user));
    } catch (e) {
      emit(UserState.error(e.toString()));
    }
  }
}
```

### Repository Pattern

```dart
abstract class UserRepository {
  Future<User> getUser(String id);
  Future<List<User>> getUsers();
}

class UserRepositoryImpl implements UserRepository {
  const UserRepositoryImpl(this._dataSource);

  final UserDataSource _dataSource;

  @override
  Future<User> getUser(String id) async {
    return await _dataSource.getUser(id);
  }
}
```

description:
globs:
alwaysApply: true

---
